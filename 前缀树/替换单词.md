# 替换单词

[剑指 Offer II 063. 替换单词 - 力扣（LeetCode）](https://leetcode.cn/problems/UhWRSj/?envType=study-plan-v2&id=coding-interviews-special)

在英语中，有一个叫做 词根(root) 的概念，它可以跟着其他一些词组成另一个较长的单词——我们称这个词为 继承词(successor)。例如，词根an，跟随着单词 other(其他)，可以形成新的单词 another(另一个)。

现在，给定一个由许多词根组成的词典和一个句子，需要将句子中的所有继承词用词根替换掉。如果继承词有许多可以形成它的词根，则用最短的词根替换它。

需要输出替换之后的句子。

```
class Solution {
    class TrieNode{
    public:
        bool isEnd;
        vector<TrieNode*>children;
        TrieNode():isEnd(false),children(26){}
    };
public:
    string replaceWords(vector<string>& dictionary, string sentence) {
        TrieNode* root = buildTrieTree(dictionary);
        string ans = "";
        string s = "";
        for(auto ch:sentence)
        {
            if(ch == ' ')
            {
                string prefix = findPrefix(root,s);
                if(prefix.empty())
                {
                    ans += s;
                }else{
                    ans += prefix;
                }
                ans += " ";
                s = "";
            }else{
                s.push_back(ch);
            }
        }
        //此时，最后sentence还剩一个单词没有处理，要单独处理一下
        string prefix = findPrefix(root,s);
        if(prefix.empty())
        {
            ans += s;
        }else{
           ans += prefix;
        }
        return ans;
    }
    TrieNode* buildTrieTree(vector<string>& dictionary)//根据字典建立前缀树
    {
        TrieNode* root = new TrieNode();
        for(auto str:dictionary)
        {
            auto node = root;
            for(auto ch:str)
            {
                if(node->children[ch - 'a'] == nullptr)
                {
                    node->children[ch - 'a'] = new TrieNode();
                }
                node = node->children[ch - 'a'];//注意，这种写法其实是把最后一个字符的下一个节点的isEnd标记为true，而非把最后一个节点标记为true
            }
            node->isEnd = true;
        }
        return root;
    }
    string findPrefix(TrieNode* root, const string& s)//在以root为根节点的前缀树里面寻找s的前缀。如果有前缀就返回前缀字符串，没有的话就返回空串
    {
        TrieNode* node = root;
        string str = "";
        for(auto ch:s)
        {
            //下面这俩顺序不能颠倒
            if(node->isEnd == true)//我们只需要找到第一个最短前缀就可以返回了，更长的前缀我们可以不用去管
                break ;
            if(node->children[ch - 'a'] == nullptr)//此时isEnd还是false，说明还没找到前缀单词，但是就已经找丢了，s里的字符在前缀树里找不到，说明没有前缀单词，返回空串
                return "";
            

            str += ch;
            node = node->children[ch - 'a'];
        }
        return str;
    }
    
};
```

