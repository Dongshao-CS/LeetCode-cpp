# 不同的二叉搜索树

**题目链接**：[96. 不同的二叉搜索树 - 力扣（LeetCode）](https://leetcode.cn/problems/unique-binary-search-trees/)

**题目要求：**给你一个整数 `n` ，求恰由 `n` 个节点组成且节点值从 `1` 到 `n` 互不相同的 **二叉搜索树** 有多少种。返回满足题意的二叉搜索树的种数。

![image-20230324110502900](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230324110502900.png)

这个题目的递推公式蛮难想的，不能从数值入手，要从树的结构入手。**假设当前根节点的左子树有m个，右子树有n个，那么以当前节点为根节点的二叉树就应该有m*n个。**

按照这个道理，如果有一个整数n，那么节点值就是从1到n有n个，每个数值都可以当作根节点。那么我们把所有的节点作为根节点时候的情况（数目）加起来，就是n个节点组成的二叉搜索树的数目了。

具体而言，对于每一个节点，它的左子树的值都比它小，如果它的值是k，左边有**k - 1**个节点，右边有**n - k**个节点，那么当前以k为根节点的树的个数应该就是k - 1个节点所能组成的树的个数去乘n - k个节点组成的树的个数。

举个例子：当n等于3的时候，看看有哪几种情况。

当1为头结点的时候，其右子树有两个节点，看这两个节点的布局，和 n 为2的时候两棵树的布局是一样的。

当3为头结点的时候，其左子树有两个节点，这两个节点的布局，和n为2的时候两棵树的布局也是一样的。

当2为头结点的时候，其左右子树都只有一个节点，布局和n为1的时候只有一棵树的布局也是一样的。

到这里就发现重叠的子问题了，可以慢慢推导出递推公式。

接下来就可以写代码了，要明确dp[n]的含义：**1到n为节点组成的二叉搜索树的个数为dp[n]，或者说，n个不同节点组成的树有多少。**

```
class Solution {
public:
    int numTrees(int n) {
        vector<int>dp(n + 1);//dp数组的含义是，dp[n]代表了n个节点有多少种二叉搜索树
        dp[0] = 1;//空节点也是一棵二叉搜索树
        dp[1] = 1;
        for(int i = 2;i <= n;i ++)
        {
            for(int j = 1;j <= i;j ++)
            {
                dp[i] += dp[j - 1]*dp[i - j];
            }
        }
        return dp[n];
    }
};
```

